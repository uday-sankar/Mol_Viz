# Mol_Viz

Mol_Viz (`MoleculeVisualizer`) is a simple Python code for 3D molecular visualization and simple animations (normal modes and MEP trajectories) built on top of `py3Dmol`, `matplotlib`, and `chemcoord`.

---

## Features

- Visualize single molecular geometries in 3D using `py3Dmol` (interactive, Jupyter-friendly).
- Plot static 3D molecular structures using `matplotlib`.
- Automatic bond detection from Cartesian coordinates using `chemcoord`.
- Animate normal modes (Cartesian or internal coordinates) and save as GIF/MP4 or XYZ/MOLDEN.
- Export MEP trajectories and normal-mode motions as multi-frame XYZ files.

---

## Installation

The code can be directly copied as a class or imported from the directory, where you wish to visualize.

### Requirements

- Python 3.x
- `numpy`
- `pandas`
- `matplotlib`
- `chemcoord`
- `py3Dmol`
- `ffmpeg` (for MP4 animation output) and/or `pillow` (for GIF output)

Install Python dependencies with:
```bash
pip install numpy pandas matplotlib chemcoord py3Dmol
```

## Usage
 
### Initialization
``` python
from molecule_visualizer import MoleculeVisualizer
import numpy as np

atoms = ["O", "H", "H"]
coords = np.array([
    [0.000000, 0.000000, 0.000000],
    [0.758602, 0.000000, 0.504284],
    [-0.758602, 0.000000, 0.504284],
])

viz = MoleculeVisualizer(
    atoms=atoms,
    coords=coords,
    int_to_cart=None,   # optional: function(q_int) -> cartesian coords
    cart_to_int=None    # optional: function(cartesian coords) -> q_int
)
```
* If `coords` is of shape `(N, 3)`, it is treated as Cartesian coordinates.
* If `coords` is a flat vector and `int_to_cart` is provided, internal coordinates can be converted on the fly where needed.

### Interactive 3D visualization (py3Dmol)
``` Python
view = viz.visualize(
    coords=None,          # defaults to viz.coords
    name="Water molecule",
    bond_radius=0.1,
    sphere_radius=0.3,
    bond_color="white",
    bond_opacity=0.9,
    width=500,
    height=500,
)
view.show()
```

### Matplotlib
``` python
ax, plt_obj = viz.visualize_matplotlib(
    coords=None,          # defaults to viz.coords
    name="Water (matplotlib)",
    ax=-1                 # pass existing Axes3D if desired
)
plt_obj.show()
```
### Animate Normal Mode
``` python
mode_vector = np.random.randn(*viz.coords.shape)  # example mode vector

viz.animate_normal_mode(
    mode_vector=mode_vector,
    scale=0.2,
    n_frames=30,
    interval=100,
    save_file="normal_mode.gif",
    title="Normal Mode Animation"
)
```
* `mode_vector` must match the shape of `coords` (`N Ã— 3`).
* Frames are generated by sinusoidal displacement along the mode.
* Output format is inferred from `save_file` extension: `.gif` uses `pillow`, anything else uses `ffmpeg`.

### Saving Normal mode animation
```python
viz.save_normal_mode_xyz(
    mode_vector=mode_vector,
    coords=None,        # defaults to viz.coords; converted if internal
    filename="mode_animation",
    n_frames=30,
    amplitude=0.1,
    filetype="xyz"      # or "molden"
)
```
* Generates `n_frames` geometries along the mode.
* Writes a multi-frame XYZ (`mode_animation.xyz`) or MOLDEN-style (`mode_animation.molden`) file.

### Animate a normal mode in internal coordinates (IC)
If a distortion in IC is know that can be animated in Cartesian. 
``` python
def int_to_cart(q_int):
    # user-provided internal -> Cartesian conversion
    ...
    
q0_int = ...              # reference internal coordinates
mode_vector_int = ...     # internal normal mode vector

viz_int = MoleculeVisualizer(
    atoms=atoms,
    coords=q0_int,
    int_to_cart=int_to_cart
)

viz_int.animate_mode_internal(
    mode_vector_int=mode_vector_int,
    q0_int=None,         # defaults to viz_int.coords
    filename="int_mode",
    n_frames=30,
    amplitude=0.1,
    filetype="xyz"       # or "molden"
)
```
This will:
* Normalize the internal mode.
* Generate displaced internal geometries.
* Convert each frame to Cartesian coordinates via `int_to_cart`.
* Save them as XYZ or MOLDEN geometries.

## Limitations
* If coordinates are not `(N, 3)` and no `int_to_cart` is provided, methods that require Cartesian coordinates will not work.
* Bond detection relies on sensible Cartesian geometries.
* py3Dmol` visualizations work best in Jupyter or other environments that support JavaScript rendering.
* For MP4 saving, ensure `ffmpeg` is installed and on your `PATH`.
## To Be Implemented
* Wilson's $B$-matrix for force conversions
* $Z$-matrix functionality within in the code. 

## Notes 
If you are used to visualization software in chemistry, you may feel that molecular visualization is already a very well-established field, and people have already implemented very good software (this code may seem redundant and useless). 

The reason I wrote all this code is to simply understand the problems better, and maybe some pieces of this code will help others in doing a tiny bit.

Even though there are multiple software, I sometimes felt gaps in visualization, especially when using Python for electronic structure calculations. So I wrote this code to fill these gaps and integrated a few different libraries. 

So most of what this code does is already well implemented and available for your use from any other molecular visualizer.

*Some parts of this code (especially the documentation) is AI generated. But I tested all functionalities and verified that most of them work without serious bugs. If you find some bugs, please let me know.*

